" local user configuration

" misc {
    " Set to auto read when a file is changed from the outside
    set autoread

    " Height of the command bar
    set cmdheight=1

    " Don't redraw while executing macros (good performance config)
    " ?
    set lazyredraw

    " No annoying sound on errors
    set noerrorbells
    set novisualbell

    " Add a bit extra margin to the left
    set foldcolumn=1

    " Use Unix as the standard file type
    set ffs=unix,dos,mac

    " Turn backup off, since most stuff is in SVN, git et.c anyway...
    set nobackup
    set nowb
    set noswapfile

    " this may not working ,try set it by hand
    set iskeyword-=.                    " '.' is an end of word designator
    set iskeyword-=#                    " '#' is an end of word designator
    set iskeyword-=-                    " '-' is an end of word designator

    " Remember info about open buffers on close
    " My session manager has saved session viminfo, but other buffer needs viminfo too.
    set viminfo^=%
    " Remap VIM 0 to first non-blank character
    map 0 ^
    "{
        " Move a line of text using ALT+[jk] or Comamnd+[jk] on mac in visual mode
        nmap <M-j> mz:m+<cr>`z
        nmap <M-k> mz:m-2<cr>`z
        vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
        vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z

        if has("mac") || has("macunix")
            nmap <D-j> <M-j>
            nmap <D-k> <M-k>
            vmap <D-j> <M-j>
            vmap <D-k> <M-k>
        endif
    "}

    " Remove the Windows ^M - when the encodings gets messed up
    "noremap <leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

    " Toggle paste mode on and off
    noremap <leader>pp :setlocal paste!<cr>

    colorscheme desert

    set nospell

    " % match pairs
    set matchpairs+=<:>
"}

" relative number {
    set relativenumber
    " switch relative number and normal number
    function! NumberToggle()
      if(&relativenumber == 1)
        set number
      else
        set relativenumber
      endif
    endfunc
"}


" tab {
    " Useful mappings for managing tabs
    nnoremap <leader>tn :tabnew<cr>
    " nnoremap <leader>to :tabonly<cr>
    nnoremap <leader>tc :tabclose<cr>
    nnoremap <leader>tm :tabmove
    " shift tab pages; i is ahead of o  likt <C-I><C-O>
    nnoremap <leader>ti :tabp<CR>
    nnoremap <leader>to :tabn<CR>
    " Opens a new tab with the current buffer's path
    " Super useful when editing files in the same directory
    nnoremap <leader>te :tabedit <c-r>=expand("%:p:h")<cr>
" }


"vimgrep searching and cope displaying {
    " Visual mode pressing * or # searches for the current selection
    " Super useful! From an idea by Michael Naumann
    vnoremap <silent> * :call VisualSelection('f', '')<CR>
    vnoremap <silent> # :call VisualSelection('b', '')<CR>

    " When you press gv you vimgrep after the selected text
    vnoremap <silent> gv :call VisualSelection('gv', '')<CR>

    " When you press <leader>r you can search and replace the selected text
    vnoremap <silent> <leader>r :call VisualSelection('replace', '')<CR>

    " Do :help cope if you are unsure what cope is. It's super useful!
    "
    " When you search with vimgrep, display your results in cope by doing:
    "   <leader>cc
    "
    " To go to the next search result do:
    "   <leader>n
    "
    " To go to the previous search results do:
    "   <leader>p
    "
    " map <leader>cc :botright cope<cr>
    " map <leader>co ggVGy:tabnew<cr>:set syntax=qf<cr>pgg
    " map <leader>n :cn<cr>
    " map <leader>p :cp<cr>

    function! CmdLine(str)
        exe "menu Foo.Bar :" . a:str
        emenu Foo.Bar
        unmenu Foo
    endfunction

    function! VisualSelection(direction, extra_filter) range
        let l:saved_reg = @"
        execute "normal! vgvy"

        let l:pattern = escape(@", '\\/.*$^~[]')
        let l:pattern = substitute(l:pattern, "\n$", "", "")

        if a:direction == 'b'
            execute "normal ?" . l:pattern . "^M"
        elseif a:direction == 'gv'
            call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)
        elseif a:direction == 'replace'
            call CmdLine("%s" . '/'. l:pattern . '/')
        elseif a:direction == 'f'
            execute "normal /" . l:pattern . "^M"
        endif

        let @/ = l:pattern
        let @" = l:saved_reg
    endfunction
" }

" buffer {
    " Close the current buffer
    map <leader>bd :Bclose<cr>
    " Close all the buffers
    map <leader>ba :1,100 bd!<cr>

    " Don't close window, when deleting a buffer
    command! Bclose call <SID>BufcloseCloseIt()
    function! <SID>BufcloseCloseIt()
       let l:currentBufNum = bufnr("%")
       let l:alternateBufNum = bufnr("#")

       if buflisted(l:alternateBufNum)
         buffer #
       else
         bnext
     endif

       if bufnr("%") == l:currentBufNum
         new
       endif

       if buflisted(l:currentBufNum)
         execute("bdelete! ".l:currentBufNum)
       endif
    endfunction
" }

" deng custom {
    set textwidth=120  " max length of a line

    "=====Folds=====
    set foldmethod=indent   " fold based on indent
    set foldnestmax=3       " deepest fold is 3 levels
    set nofoldenable        " don't fold by default
    nnoremap <Space> za     " use space to do fold

    noremap <leader>vd :vertical diffsplit

    " Only needed for a short time so...
    noremap <leader>fd :setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1<CR>

    " set ; to : in normal mode, more fast to cmd mode.
    nnoremap ; :
    nnoremap : ;

    " not replace paste content
    xnoremap p pgvy

    noremap <leader>s i <Esc>

    noremap <leader>m :marks<CR>

    "===============================
    "   project
    "===============================
    noremap <leader>dt :cd ~/Desktop<CR>
    noremap <leader>pj :cd /Users/pinganhaofang/1_Project/<CR>

    set encoding=utf-8
    set fenc=utf-8
    set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1

    noremap <leader>w :w<CR>
    " replace a word
    nmap vp viwp

    " when switch vertical windows, make the other window visiable
    set winheight=5
    set winminheight=5

    " display bottom scroller
    set guioptions+=b
" }

" custom Plugins {
    """"""""""""""""""""""""""""""""""""""""
    " ConqueTerm plugin
    let g:ConqueTerm_FastMode = 0 " 1 enable fast mode, 0 disable
    let g:ConqueTerm_Color = 1  " Color support
    let g:ConqueTerm_SessionSupport = 0 " save to session

    "{
        "Type :ConqueTerm <command> to run your command in vim, for example:
        ":ConqueTerm bash

        "To open ConqueTerm in a new horizontal or vertical buffer use:
        ":ConqueTermSplit <command>
        ":ConqueTermVSplit <command>
        ":ConqueTermTab <command>
    "}

    """"""""""""""""""""""""""""""""""""""""
    " powerline plugin
    let g:Powerline_symbols = 'fancy'

    """""""""" NERDtree settings"""""""""""""""
    let g:NERDTreeWinPos='left'

    """"""""""EasyMotion settings""""""""""
    ""let g:EasyMotion_leader_key = '\'
        " ff[ch]
        " fs[ch]    Search
        " fw    word
        " fj    line downward
        " fk    line upward
        " fn/fN    like original n/N

" }
"

let g:user_emmet_leader_key = '<c-s>'
autocmd FileType css imap <Tab> <plug>(EmmetExpandAbbr)
autocmd FileType html imap <Tab> <plug>(EmmetExpandAbbr)

" js beautify
autocmd FileType javascript vnoremap <buffer> <C-S> :call RangeJsBeautify()<cr>
autocmd FileType javascript vnoremap <buffer> <C-H> :call RangeHtmlBeautify()<cr>
autocmd FileType json vnoremap <buffer> <C-S> :call RangeJsonBeautify()<cr>
autocmd FileType jsx vnoremap <buffer>  <C-S> :call RangeJsxBeautify()<cr>
autocmd FileType html vnoremap <buffer> <C-S> :call RangeHtmlBeautify()<cr>
autocmd FileType css vnoremap <buffer>  <C-S> :call RangeCSSBeautify()<cr>

set lines=80

" ----------------------------------------------------------------------------
" tern_for_vim
" ----------------------------------------------------------------------------
let tern_show_signature_in_pum = 1
let tern_show_argument_hints = 'on_hold'
autocmd FileType javascript nnoremap <leader>d :TernDef<CR>
autocmd FileType javascript set omnifunc=tern#Complete

"surrounding command list {
    "Normal mode
    "-----------
    "ds  - delete a surrounding
    "cs  - change a surrounding
    "ys  - add a surrounding
    "yS  - add a surrounding and place the surrounded text on a new line + indent it
    "yss - add a surrounding to the whole line
    "ySs - add a surrounding to the whole line, place it on a new line + indent it
    "ySS - same as ySs

    "Visual mode
    "-----------
    "S   - in visual mode, add a surrounding but place text on new line + indent it

    "Insert mode
    "-----------
    "<CTRL-s> - in insert mode, add a surrounding
    "<CTRL-s><CTRL-s> - in insert mode, add a new line + surrounding + indent
    "<CTRL-g>s - same as <CTRL-s>
    "<CTRL-g>S - same as <CTRL-s><CTRL-s>
"}
"

" fix NERDTreeToggle error strangely. {
    noremap <C-e> :call g:WorkaroundNERDTreeToggle()<CR>

    function! g:WorkaroundNERDTreeToggle()
      try | NERDTreeToggle | catch | silent! NERDTree | endtry
    endfunction

    noremap ,pr :NERDTreeFind<CR>
"}

set cpt=.,b,u,U,t,i
inoremap <D-p> <c-x><c-p>

" buffer switch {
    function! BufSel(pattern)
      let bufcount = bufnr("$")
      let currbufnr = 1
      let nummatches = 0
      let firstmatchingbufnr = 0
      while currbufnr <= bufcount
        if(bufexists(currbufnr))
          let currbufname = bufname(currbufnr)
          if(match(currbufname, a:pattern) > -1)
            echo currbufnr . ": ". bufname(currbufnr)
            let nummatches += 1
            let firstmatchingbufnr = currbufnr
          endif
        endif
        let currbufnr = currbufnr + 1
      endwhile
      if(nummatches == 1)
        execute ":buffer ". firstmatchingbufnr
      elseif(nummatches > 1)
        let desiredbufnr = input("Enter buffer number: ")
        if(strlen(desiredbufnr) != 0)
          execute ":buffer ". desiredbufnr
        endif
      else
        echo "No matching buffers"
      endif
    endfunction

    "Bind the BufSel() function to a user-command
    command! -nargs=1 Bs :call BufSel("<args>")
"}

set foldlevelstart=1

" ctrlp {
    "https://kien.github.io/ctrlp.vim/
    "使用:CtrlP或:CtrlP [starting-directory]调用CtrlP进入查找文件模式
    "使用:CtrlPBuffer或:CtrlPMRU进入查找buffer或者查找MRU文件模式
    "使用:CtrlPMixed同时搜索普通文件、Buffers或者MRU文件
    "可以使用:help ctrlp-commands和:help ctrlp-extensions查看其他命令帮助

    "一旦CtrlP被打开了，就可以使用以下的命令
        "<F5> 清除当前目录下的缓存，获取新的结构
        "<c-f>和<c-b> 在各个模式下转换
        "<c-d> 使用文件名搜索代替全路径搜索
        "<c-r> 使用正则模式
        "<c-j>和<c-k> 上下选择文件
        "<c-t> <c-v>和<c-x> 在新的tab或者新的分割窗口打开选择的文件
        "<c-n>和<c-p> 找到之前或者之后查找的字符串
        "<c-y> 创建一个新的文件
        "<c-z> 标记或者取消标记多个文件然后使用<c-o>打开它们
        "<c-o> 选择打开方式
        "
    " use ,fu search fun tag -> CtrlPFunky
    let g:ctrlp_max_depth = 40
    let g:ctrlp_max_files = 0
    let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:20,results:100'
    " search by file name
    let g:ctrlp_by_filename = 1
    " home path display ~
    let g:ctrlp_tilde_homedir = 1
    " only show current working dir recent files.
    " open new buffer to open other recent files
    let g:ctrlp_mruf_relative = 1
    " NOTE:
        " if install ag with brew, below setting will be invalid
        " let g:ctrlp_custom_ignore
        " edit ~/.agignore to add folders to be ignore.
        " Ag will ignore anything that you have in your .gitignore.
        " You can also create an .agignore for anything that doesn’t belong in your .gitignore.
        " http://erickel.ly/ignoring-filesdirectories-with-ctrlp

    " current dir
    let g:ctrlp_map = '<D-p>'
    let g:ctrlp_cmd = 'CtrlP'
    " recent files
    nnoremap <silent> <D-r> :CtrlPMRU<CR>
    " buffers
    nnoremap <silent> <D-b> :CtrlPBuffer<CR>

    if has('python') || has('python3')
        let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
    endif

    " Use <c-n/p> to select item and <c-j/k> browse history
    let g:ctrlp_prompt_mappings = {
    \ 'PrtSelectMove("j")':   ['<c-n>', '<down>'],
    \ 'PrtSelectMove("k")':   ['<c-p>', '<up>'],
    \ 'PrtHistory(-1)':       ['<c-j>'],
    \ 'PrtHistory(1)':        ['<c-k>'],
    \ }

    " use word under cursor as CtrlP input
    nnoremap <Leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<CR>
    " https://github.com/kien/ctrlp.vim/issues/218
    nnoremap <silent> ,fw :let g:ctrlp_default_input = expand('<cword>')<cr>:CtrlP<cr>

    " 可以参考
    " https://github.com/fisadev/fisa-vim-config
    "{  这种方法有点玄幻
        "function! CtrlPWithSearchText(search_text, ctrlp_command_end)
            "execute ':CtrlP' . a:ctrlp_command_end
            "call feedkeys(a:search_text)
        "endfunction
        "nnoremap ,we :call CtrlPWithSearchText(expand('<cword>'), '')<CR>
    "}
    " }

"{
    "Cocoa.vim
    ":help cocoa
    "cocoa.vim uses snipMate to code completion
    "<c-x><c-o>
    "<tab>
    "useful plugin: objc_matchbracket.vim
    ":ListMethods
    ":BuildMethods .h -> .m
    "look document
    ":CocoaDoc
    "K
    "Xcode-like mappings
    "<Leader>A Alternate between header (.h) and implementation (.m) file
    "K Look up documentation for word under cursor
    "<d-m-up> equal <Leader>A
    "<d-r> Build & Run (Go)
    "<d-cr> CMD-R
    "<d-b> Build
    "<shift-k> Clean
    "<d-0> Go to Project
    "<d-2> :ListMethods
    "<F5> (in insert mode) Show omnicompletion menu
    "<d-/> Comment out line
    "<d-[> Decrease indent
    "<d-]> Increase indent
    "a.vim
    ":A switches to the header file corresponding to the current file being edited (or vise versa)
    ":AS splits and switches
    ":AV vertical splits and switches
    ":AT new tab and switches
    ":AN cycles through matches
    ":IH switches to file under cursor
    ":IHS splits and switches
    ":IHV vertical splits and switches
    ":IHT new tab and switches
    ":IHN cycles through matches
    "<Leader>ih switches to file under cursor
    "<Leader>is switches to the alternate file of file under cursor (e.g. on switches to foo.cpp)
    "<Leader>ihn cycles through matches
"}

" a.vim {
    let g:alternateExtensions_m = "h"
    let g:alternateExtensions_mm = "h"
    let g:alternateExtensions_h = "m,mm"
"}

" Easy motion {
    let g:EasyMotion_smartcase = 1
    " 行级跳转(jk)
    map <Leader><Leader>j <Plug>(easymotion-j)
    map <Leader><Leader>k <Plug>(easymotion-k)
    " 行内跳转(hl)
    map <Leader><leader>h <Plug>(easymotion-linebackward)
    map <Leader><leader>l <Plug>(easymotion-lineforward)
    " 重复上一次动作(.)
    map <Leader><leader>. <Plug>(easymotion-repeat)
"}

" K search current folder
" ,k search custom folder by g:grep_root_dir
" {
    if executable('ag')
      " Use ag over grep
      set grepprg=ag\ --nogroup\ --nocolor
    endif

    autocmd FileType shell setlocal keyworkprg=man\ -s
    set keywordprg=grep\ --color=auto\ -r\ -n\ ./*\ -e

    " set grep search root dir, save with session
    " file path can't contain white space
    " iOS SDK root: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.2.sdk
    let g:grep_root_dir='~/Documents'
    function! GrepCustomDir(word)
        execute 'grep! ' . a:word . ' ' . g:grep_root_dir
        cw
    endfunction

    nnoremap ,k :call GrepCustomDir("<C-R><C-W>")<CR>
"}

" Easygrep search current folder only
" {
    "<Leader>vv  - Grep for the word under the cursor, match all occurences,
                  "like |gstar|
    "<Leader>vV  - Grep for the word under the cursor, match whole word, like
                  "|star|
    "<Leader>va  - Like vv, but add to existing list
    "<Leader>vA  - Like vV, but add to existing list
    "<Leader>vr  - Perform a global search search on the word under the cursor
                  "and prompt for a pattern with which to replace it.
    "<Leader>vo  - Select the files to search in and set grep options
    "<Leader>vy* - Invoke any option from the options explorer, where * is the
                  "shortcut for that option.
                  "e.g. <Leader>vyr - toggles recursion
                       "<Leader>vyb - sets buffer grepping mode
                       "etc.
    let g:EasyGrepMode = 2     " All:0, Open Buffers:1, TrackExt:2,
    let g:EasyGrepCommand = 1  " Use vimgrep:0, grepprg:1
    let g:EasyGrepRecursive  = 1 " Recursive searching
    let g:EasyGrepIgnoreCase = 1 " not ignorecase:0
    let g:EasyGrepFilesToExclude = "*.bak, cscope.*, *.a, *.o, *.pyc, *.bak, *.zip"
"}

" ycm {
    let g:ycm_filetype_blacklist = {
      \ 'tagbar' : 1,
      \ 'qf' : 1,
      \ 'notes' : 1,
      \ 'markdown' : 1,
      \ 'unite' : 1,
      \ 'text' : 1,
      \ 'vimwiki' : 1,
      \ 'gitcommit' : 1,
      \}
    " 获取编译数据
    "https://github.com/rizsotto/Bear
    let g:ycm_extra_conf_vim_data = ['&filetype']
"}

"vim-ios {
    ":A Switch to alternate file
    ":XBuild    Compile Project
    ":Xinstall  Install on device
"}

" copy file path {
    " copy current file name (relative/absolute) to system clipboard
    if has("mac") || has("gui_macvim") || has("gui_mac")
      " relative path  (src/foo.txt)
      nnoremap <leader>cf :let @*=expand("%")<CR>

      " absolute path  (/something/src/foo.txt)
      nnoremap <leader>cF :let @*=expand("%:p")<CR>

      " filename       (foo.txt)
      nnoremap <leader>ct :let @*=expand("%:t")<CR>

      " directory name (/something/src)
      nnoremap <leader>ch :let @*=expand("%:p:h")<CR>
    endif
"}

set clipboard=unnamed,autoselect

" http://www.vimer.cn/2009/10/%E5%9C%A8vim%E4%B8%AD%E4%BD%BF%E7%94%A8ctags.html
" brew install ctags --HEAD
" find . -name "*.h" -o -name "*.c" -o -name "*.cpp" -o -name "*.m" -o -name "*.mm" -o -name "*.js"> src.files
" ctags --exclude='.git' -R --c++-kinds=+px --fields=+iaS --extra=+q --langmap=ObjectiveC:.m.h -L src.files
" set tags+=tags的文件路径
" tagbar 替代了 taglist
" 解析非常严格需要格式代 brew install clang-format
" objc tags {
    "http://bastibe.de/2011-12-04-how-to-make-tagbar-work-with-objective-c.html
    " add a definition for Objective-C to tagbar
    set tags+=~/1_Project/XVim_x/XVim/tags
    set tags+=/Users/pinganhaofang/1_Project/guanjia/tags
    let g:tagbar_type_objc = {
        \ 'ctagsbin' : '~/ctags',
        \ 'ctagstype' : 'Objc',
        \ 'kinds'     : [
            \ 'i:interface',
            \ 'I:implementation',
            \ 'P:Protocol',
            \ 'M:Object_method',
            \ 'C:Class_method',
            \ 'Z:Protocol_method'
        \ ],
        \ 'sro'        : ' ',
        \ 'kind2scope' : {
            \ 'i' : 'interface',
            \ 'I' : 'implementation',
            \ 'P' : 'Protocol',
        \ },
        \ 'scope2kind' : {
            \ 'interface'      : 'i',
            \ 'implementation' : 'I',
            \ 'Protocol'       : 'P',
        \ }
    \ }
    "let g:tagbar_type_objc = {
        "\ 'ctagstype' : 'ObjectiveC',
        "\ 'kinds'     : [
            "\ 'i:interface',
            "\ 'I:implementation',
            "\ 'P:Protocol',
            "\ 'm:Object_method',
            "\ 'c:Class_method',
            "\ 'v:Global_variable',
            "\ 'F:Object field',
            "\ 'f:function',
            "\ 'p:property',
            "\ 't:type_alias',
            "\ 's:type_structure',
            "\ 'e:enumeration',
            "\ 'M:preprocessor_macro',
        "\ ],
        "\ 'sro'        : ' ',
        "\ 'kind2scope' : {
            "\ 'i' : 'interface',
            "\ 'I' : 'implementation',
            "\ 'P' : 'Protocol',
            "\ 's' : 'type_structure',
            "\ 'e' : 'enumeration'
        "\ },
        "\ 'scope2kind' : {
            "\ 'interface'      : 'i',
            "\ 'implementation' : 'I',
            "\ 'Protocol'       : 'P',
            "\ 'type_structure' : 's',
            "\ 'enumeration'    : 'e'
        "\ }
    "\ }

    "install https://github.com/mozilla/doctorjs
    let g:tagbar_type_javascript = {
    \ 'ctagsbin' : '~/spf13-copy-vim/vim/bundle/doctorjs/bin/jsctags'
    \ }

    " ctags --list-kinds=all
    " ctags --list-kinds=ObjectiveC
    "ObjectiveC
        "i  class interface
        "I  class implementation
        "p  Protocol
        "m  Object's method
        "c  Class' method
        "v  Global variable
        "F  Object field
        "f  A function
        "p  A property
        "t  A type alias
        "s  A type structure
        "e  An enumeration
        "M  A preprocessor macro
    "JavaScript
        "f  functions
        "c  classes
        "m  methods
        "p  properties
        "v  global variables
"}

" Useful Substitute {
    " Del line tail blank space 行尾空格
    ":%s/\s\+$//

    "Doe, John > John Doe
    ":%s/\([^,]*\), \(.*\)/\2 \1/
"}:%s/\s\+$//


" gf search path and sub path {
    if g:gitroot != ''
        execute 'set path=./**,' . g:gitroot . '/**'
    endif
"}

" expand tab {
    function! ChangeTabToSpace()
        set expandtab
        %retab!
    endfunction

    function! ChangeSpace2Tab()
        set noexpandtab
        %retab!
    endfunction

    command -nargs=0 ChangeSpace2Tab :call ChangeSpace2Tab()
    command -nargs=0 ChangeTab2Space :call ChangeTab2Space()
"}

" command {
    " 命令需要大写开头
    "command -nargs=+ Say :echo "<args>"
        "-nargs=0   zero
        "-nargs=1   one
        "-nargs=*   any
        "-nargs=?    one or zero
        "-nargs=+    one or more
        " <args>
        " <q-args>  包含特殊字符
        " <f-args>  适合函数调用

    "autocmd [group] {events} {file_pattern} [nested] {command}
    "autocmd BufNewFile     *.[ch]  0read ~/skeletons/skel.c     打开一个新文件
    "autocmd FileType       text    source ~/.vim/abbrevs.vim    设置filetype
    "autocmd BufReadPost    *.gsm   set filetype=asm             开始编辑一个文件
"}

" {
    " normal mode
    "g/xxx/d，删除包含xxx的行
    "v/xxx/d，删除不含xxx的行
    ":%s/xxx//gn，统计xxx个数，n表示只报告匹配的个数而不进行实际的替换。
"}

" zsh {
    if executable('zsh')
        set shell=/bin/zsh
    endif
"}

" REST 
" require Vim 7.4 & cURL {
    " file suffix is .rest
    " set ft=rest

    " show response in new buffer
    let b:vrc_output_buffer_name = '__REST_1_OUTPUT__'
    let g:vrc_ssl_secure = 1
    " more usage
    " https://raw.githubusercontent.com/diepm/vim-rest-console/master/sample.rest
    " https://github.com/diepm/vim-rest-console

    autocmd FileType  rest let g:vrc_trigger = '<C-j>'

    "Tips: use echo to show unicode word. :echo "\u8bf7"

    " Get python install location
    " >>> import site; site.getsitepackages()

    " Another tool: https://github.com/jkbrzt/httpie

    " Simple usage
    " :r ! curl http://api.app.qa.anhouse.com.cn/hft/1.0/home_city_list | python ~/spf13-copy-vim/bin/json.tool.py  

    let g:vrc_auto_format_response_patterns = {
    \   'json': 'python ~/spf13-copy-vim/bin/json.tool.py',
    \   'xml': 'xmllint --format -',
    \}
"}
