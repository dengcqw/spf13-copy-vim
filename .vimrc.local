" local user configuration

" misc {
    " Set to auto read when a file is changed from the outside
    set autoread

    " Height of the command bar
    set cmdheight=1

    " Don't redraw while executing macros (good performance config)
    " ?
    "set lazyredraw

    " No annoying sound on errors
    set noerrorbells
    set novisualbell

    " Use Unix as the standard file type
    set ffs=unix,dos,mac

    " Turn backup off, since most stuff is in SVN, git et.c anyway...
    set nobackup
    set nowb
    set noswapfile

    " Remember info about open buffers on close
    " My session manager has saved session viminfo, but other buffer needs viminfo too.
    "set viminfo^=%

    " Remap VIM 0 to first non-blank character
    map 0 ^
    "{
        " Move a line of text using ALT+[jk] or Comamnd+[jk] on mac in visual mode
        nmap <M-j> mz:m+<cr>`z
        nmap <M-k> mz:m-2<cr>`z
        vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
        vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z

        if has("mac") || has("macunix")
            nmap <D-j> <M-j>
            nmap <D-k> <M-k>
            vmap <D-j> <M-j>
            vmap <D-k> <M-k>
        endif
    "}

    " select block
    noremap vab Vf{%

    " Remove the Windows ^M - when the encodings gets messed up
    "noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

    " Toggle paste mode on and off
    noremap <Leader>pp :setlocal paste!<cr>

    set nospell

    " % match pairs
    set matchpairs+=<:>

    " quiclfix/location open buffer options
    set switchbuf=useopen,usetab,newtab
"}

" relative number {
    set number
    " switch relative number and normal number
    function! NumberToggle()
      if(&relativenumber == 1)
        set number
      else
        set relativenumber
      endif
    endfunc
"}


" tab {
    " Useful mappings for managing tabs
    nnoremap <Leader>tn :tabnew<cr>
    " nnoremap <Leader>to :tabonly<cr>
    nnoremap <Leader>tc :tabclose<cr>
    nnoremap <Leader>tm :tabmove
    " shift tab pages; i is ahead of o  likt <C-I><C-O>
    nnoremap <Leader>ti :tabp<CR>
    nnoremap <Leader>to :tabn<CR>
    " Opens a new tab with the current buffer's path
    " Super useful when editing files in the same directory
    nnoremap <Leader>te :tabedit <c-r>=expand("%:p:h")<cr>
" }


"vimgrep searching and cope displaying {
    " Visual mode pressing * or # searches for the current selection
    " Super useful! From an idea by Michael Naumann
    vnoremap <silent> * :call VisualSelection('f', '')<CR>
    vnoremap <silent> # :call VisualSelection('b', '')<CR>

    " When you press gv you vimgrep after the selected text
    vnoremap <silent> gv :call VisualSelection('gv', '')<CR>
    vnoremap <silent> K :call VisualSelection('K', '')<CR>

    function! CmdLine(str)
        exe "menu Foo.Bar :" . a:str
        emenu Foo.Bar
        unmenu Foo
    endfunction

    function! VisualSelection(direction, extra_filter) range
        let l:saved_reg = @"
        execute "normal! vgvy"

        let l:pattern = escape(@", '\\/.*$^~[]')
        let l:pattern = substitute(l:pattern, "\n$", "", "")

        if a:direction == 'b'
            execute "normal ?" . l:pattern . "^M"
        elseif a:direction == 'gv'
            call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)
        elseif a:direction == 'replace'
            call CmdLine("%s" . '/'. l:pattern . '/')
        elseif a:direction == 'f'
            execute "normal /" . l:pattern . "^M"
        elseif a:direction == 'K'
            execute 'Ack! ' . '"' . l:pattern . '"'
        endif

        let @/ = l:pattern
        let @" = l:saved_reg
    endfunction
" }

" buffer {
    " Close the current buffer
    "map <Leader>bd :Bclose<cr>
    " Close all the buffers
    "map <Leader>ba :1,100 bd!<cr>

    " Don't close window, when deleting a buffer
    command! Bclose call <SID>BufcloseCloseIt()
    function! <SID>BufcloseCloseIt()
       let l:currentBufNum = bufnr("%")
       let l:alternateBufNum = bufnr("#")

       if buflisted(l:alternateBufNum)
         buffer #
       else
         bnext
     endif

       if bufnr("%") == l:currentBufNum
         new
       endif

       if buflisted(l:currentBufNum)
         execute("bdelete! ".l:currentBufNum)
       endif
    endfunction
" }

" deng custom {
    set textwidth=120  " max length of a line
    " 影响终端显示
    set lines=80

    "=====Folds=====
    set foldmethod=indent   " fold based on indent
    set foldnestmax=9       " deepest fold is 3 levels
    set nofoldenable        " don't fold by default
    nnoremap <Space> za     " use space to do fold
    set foldlevelstart=1
    " Add a bit extra margin to the left
    set foldcolumn=1

    " add filename after command
    noremap <Leader>vd :vertical diffsplit
    " Only needed for a short time so...
    noremap <Leader>fd :setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1<CR>

    " set ; to : in normal mode, more fast to cmd mode.
    nnoremap ; :
    nnoremap : ;

    " not replace paste content
    xnoremap p pgvy

    noremap <Leader>m :marks<CR>

    set encoding=utf-8
    set fenc=utf-8
    set fileencoding=utf-8
    set fileencodings=ucs-bom,utf-8,gb18030,cp936,big5,euc-jp,euc-kr,latin1

    noremap <Leader>w :w<CR>
    " replace a word
    nmap vp viwp

    " when switch vertical windows, make the other window visiable
    set winheight=5
    set winminheight=5

    " display bottom scroller
    set guioptions+=b

    set complete=.,b,u,U,k

    inoremap <D-p> <c-x><c-p>

    "set nocursorline
    set nocursorcolumn
    "set synmaxcol=200

" }

" custom Plugins {

"""""""""" NERDtree settings"""""""""""""""
let g:NERDTreeWinPos='left'

" fix NERDTreeToggle error strangely. {
    "noremap <C-e> :call g:WorkaroundNERDTreeToggle()<CR>

    "function! g:WorkaroundNERDTreeToggle()
      "try | NERDTreeTabsToggle | catch | silent! NERDTree | endtry
    "endfunction

    noremap <Leader>pr :NERDTreeFind<CR>
"}

" keep auto-open-nerdtree-in-every-tab
" https://stackoverflow.com/a/2762067/2434742
"autocmd BufWinEnter * NERDTreeMirror
"autocmd VimEnter * NERDTree
"autocmd BufEnter * NERDTreeMirror
let NERDTreeQuitOnOpen=0


" emmet
let g:user_emmet_leader_key = '<C-S>'
let g:user_emmet_install_global = 0
autocmd FileType html,vue EmmetInstall


" js beautify
augroup filetype_jsbuty
    autocmd!
    autocmd FileType javascript vnoremap <buffer> <C-S> :call RangeJsBeautify()<cr>
    autocmd FileType javascript vnoremap <buffer> <C-H> :call RangeHtmlBeautify()<cr>
    autocmd FileType json vnoremap <buffer> <C-S> :call RangeJsonBeautify()<cr>
    autocmd FileType jsx vnoremap <buffer>  <C-S> :call RangeJsxBeautify()<cr>
    autocmd FileType html vnoremap <buffer> <C-S> :call RangeHtmlBeautify()<cr>
    autocmd FileType css vnoremap <buffer>  <C-S> :call RangeCSSBeautify()<cr>
augroup END


" vim-javascript.vim
let g:javascript_enable_domhtmlcss = 1
"javascript-libraries-syntax.vim
"autocmd BufReadPre *.js let b:javascript_lib_use_jquery = 1
let g:used_javascript_libs = 'underscore,react'
" vim-jsx.vim
let g:jsx_ext_required = 0

function! ChangeJavascriptTab()
    set tabstop=2
    set softtabstop=2
    set shiftwidth=2
    set expandtab
endfunction

augroup filetype_jsformat
    autocmd!
    autocmd FileType typescript,javascript,typescriptreact,javascriptreact  :call ChangeJavascriptTab()
    autocmd FileType typescript,javascript,typescriptreact,javascriptreact vnoremap <silent> = :'<,'>:PrettierFragment<CR>
    autocmd FileType typescript,javascript,typescriptreact,javascriptreact let b:ale_linters = ['eslint']
    autocmd FileType typescript,javascript,typescriptreact,javascriptreact let b:ale_fixers = ['eslint', 'prettier']
augroup END

"surrounding command list {
    "Normal mode
    "-----------
    "ds  - delete a surrounding
    "cs  - change a surrounding
    "ys  - add a surrounding
    "yS  - add a surrounding and place the surrounded text on a new line + indent it
    "yss - add a surrounding to the whole line
    "ySs - add a surrounding to the whole line, place it on a new line + indent it
    "ySS - same as ySs

    "Visual mode
    "-----------
    "S   - in visual mode, add a surrounding but place text on new line + indent it
    vmap <silent> " S"
    vmap <silent> ' S'
    vmap <silent> ` S`
    vmap <silent> ( S(
    vmap <silent> ) S)
    vmap <silent> [ S[
    vmap <silent> ] S]
    vmap <silent> { S{
    vmap <silent> } S}

    "Insert mode
    "-----------
    "<CTRL-s> - in insert mode, add a surrounding
    "<CTRL-s><CTRL-s> - in insert mode, add a new line + surrounding + indent
    "<CTRL-g>s - same as <CTRL-s>
    "<CTRL-g>S - same as <CTRL-s><CTRL-s>
"}

" ctrlp {
    "https://kien.github.io/ctrlp.vim/
    "使用:CtrlP或:CtrlP [starting-directory]调用CtrlP进入查找文件模式
    "使用:CtrlPBuffer或:CtrlPMRU进入查找buffer或者查找MRU文件模式
    "使用:CtrlPMixed同时搜索普通文件、Buffers或者MRU文件
    "可以使用:help ctrlp-commands和:help ctrlp-extensions查看其他命令帮助

    "一旦CtrlP被打开了，就可以使用以下的命令
        "<F5> 清除当前目录下的缓存，获取新的结构
        "<c-f>和<c-b> 在各个模式下转换
        "<c-d> 使用文件名搜索代替全路径搜索
        "<c-r> 使用正则模式
        "<c-j>和<c-k> 上下选择文件
        "<c-t> <c-v>和<c-x> 在新的tab或者新的分割窗口打开选择的文件
        "<c-n>和<c-p> 找到之前或者之后查找的字符串
        "<c-y> 创建一个新的文件
        "<c-z> 标记或者取消标记多个文件然后使用<c-o>打开它们
        "<c-o> 选择打开方式
        "
    " use ,fu search fun tag -> CtrlPFunky
    "let g:ctrlp_max_depth = 5   not working when use ctrlp_user_command ?
    "let g:ctrlp_max_files = 100
    let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:20,results:100'
    " search by file name
    let g:ctrlp_by_filename = 1
    " home path display ~
    let g:ctrlp_tilde_homedir = 1
    " only show current working dir recent files.
    " open new buffer to open other recent files
    let g:ctrlp_mruf_relative = 1
    " NOTE:
        " if install ag with brew, it will be use as search command in ctrlp_user_command
        " ctrlp_user_command has option 'igonre',
        " see help Note #3, switch to use external command ignore or ctrlp_custom_ignore
        " edit ~/.agignore to add folders to be ignore.
        " Ag will ignore anything that you have in your .gitignore.
        " You can also create an .agignore for anything that doesn’t belong in your .gitignore.
        " http://erickel.ly/ignoring-filesdirectories-with-ctrlp

    " current dir
    let g:ctrlp_map = '<D-p>'
    let g:ctrlp_cmd = 'CtrlP'
    " recent files
    "nnoremap <silent> <D-r> :CtrlPMRU<CR>
    " buffers
    "nnoremap <silent> <D-b> :CtrlPBuffer<CR>

    if has('python') || has('python3')
        let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
    endif

    " Use <c-n/p> to select item and <c-j/k> browse history
    let g:ctrlp_prompt_mappings = {
    \ 'PrtSelectMove("j")':   ['<c-n>', '<down>'],
    \ 'PrtSelectMove("k")':   ['<c-p>', '<up>'],
    \ 'PrtHistory(-1)':       ['<c-j>'],
    \ 'PrtHistory(1)':        ['<c-k>'],
    \ }

    " use word under cursor as CtrlP input
    "nnoremap <Leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<CR>
    " https://github.com/kien/ctrlp.vim/issues/218
    "nnoremap <silent> <Leader>fw :let g:ctrlp_default_input = expand('<cword>')<cr>:CtrlP<cr>

    " 可以参考
    " https://github.com/fisadev/fisa-vim-config
    "{  这种方法有点玄幻
        "function! CtrlPWithSearchText(search_text, ctrlp_command_end)
            "execute ':CtrlP' . a:ctrlp_command_end
            "call feedkeys(a:search_text)
        "endfunction
        "nnoremap ,we :call CtrlPWithSearchText(expand('<cword>'), '')<CR>
    "}
    " }

" Easy motion {
  "let g:EasyMotion_leader_key = '\'
  " ff[ch]
  " fs[ch]    Search
  " fw    word
  " fj    line downward
  " fk    line upward
  " fn/fN    like original n/N

    let g:EasyMotion_smartcase = 1
    let g:EasyMotion_off_screen_search = 0
    let g:EasyMotion_disable_two_key_combo = 1
    " 行级跳转(jk)
    map <Leader>j <Plug>(easymotion-j)
    map <Leader>k <Plug>(easymotion-k)
    " 行内跳转(hl)
    map <Leader>h <Plug>(easymotion-linebackward)
    map <Leader>l <Plug>(easymotion-lineforward)
    " 重复上一次动作(.)
    "map <Leader>. <Plug>(easymotion-repeat)
"}

" K -- the uppercase k search current folder
" {
    if executable('ag')
      " Use ag over grep
      set grepprg=ag\ --nogroup\ --nocolor\ -U
    endif

    "autocmd FileType shell setlocal keyworkprg=man\ -s
    set keywordprg=grep\ --color=auto\ -r\ -n\ ./*\ -e

    " set grep search root dir, save with session
    " file path can't contain white space
    " iOS SDK root: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.2.sdk
    " Tips: Don't change path to the file, keep the project path, use ,pr to locate file in NERD tree
    function! GrepCustomDir(word)
        " use ag search
        "execute 'grep! ' . a:word . ' ' . './'
        if len(a:word) < 3
            echoerr "search word length less then 4"
            return
        endif
        execute 'Ack! -U ' . a:word
        cw
    endfunction

    nnoremap K :call GrepCustomDir("<C-R><C-W>")<CR>
"}

" copy file path {
    " copy current file name (relative/absolute) to system clipboard
    if has("mac") || has("gui_macvim") || has("gui_mac")
      " relative path  (src/foo.txt)
      nnoremap <Leader>cf :let @*=expand("%")<CR>

      " absolute path  (/something/src/foo.txt)
      nnoremap <Leader>cF :let @*=expand("%:p")<CR>

      " filename       (foo.txt)
      nnoremap <Leader>ct :let @*=expand("%:t")<CR>

      " directory name (/something/src)
      nnoremap <Leader>ch :let @*=expand("%:p:h")<CR>
    endif
"}

" brew install ctags --HEAD  // support objc
" find . -name "*.h" -o -name "*.c" -o -name "*.cpp" -o -name "*.m" -o -name "*.mm" -o -name "*.js"> src.files
" ctags --exclude='.git' -R --c++-kinds=+px --fields=+iaS --extra=+q --langmap=ObjectiveC:.m.h -L src.files
" set tags+=tags的文件路径
" tagbar 替代了 taglist
" 解析非常严格需要格式代 brew install clang-format
" objc tags {
    "http://bastibe.de/2011-12-04-how-to-make-tagbar-work-with-objective-c.html
    " add a definition for Objective-C to tagbar
 let g:tagbar_type_objc = {
    \ 'ctagstype' : 'ObjectiveC',
    \ 'kinds'     : [
        \ 'i:interface',
        \ 'I:implementation',
        \ 'p:Protocol',
        \ 'm:Object_method',
        \ 'c:Class_method',
        \ 'v:Global_variable',
        \ 'F:Object field',
        \ 'f:function',
        \ 'p:property',
        \ 't:type_alias',
        \ 's:type_structure',
        \ 'e:enumeration',
        \ 'M:preprocessor_macro'
    \ ]
\ }

    " ctags --list-kinds=all
    " ctags --list-kinds=ObjectiveC
    "ObjectiveC
        "i  class interface
        "I  class implementation
        "p  Protocol
        "m  Object's method
        "c  Class' method
        "v  Global variable
        "F  Object field
        "f  A function
        "p  A property
        "t  A type alias
        "s  A type structure
        "e  An enumeration
        "M  A preprocessor macro
    "JavaScript
        "f  functions
        "c  classes
        "m  methods
        "p  properties
        "v  global variables
"}

" Useful Substitute {
    " Del line tail blank space 行尾空格
    ":%s/\s\+$//

    "Doe, John > John Doe
    ":%s/\([^,]*\), \(.*\)/\2 \1/
"}:%s/\s\+$//


" gf search path and sub path {
    if isdirectory(expand(g:gitroot))
        execute 'set path=./**,' . g:gitroot . '/**'
    endif
"}

" expand tab {
    "function! ChangeTabToSpace()
        "set expandtab
        "%retab!
    "endfunction

    "function! ChangeSpace2Tab()
        "set noexpandtab
        "%retab!
    "endfunction

    "command -nargs=0 ChangeSpace2Tab :call ChangeSpace2Tab()
    "command -nargs=0 ChangeTab2Space :call ChangeTab2Space()
"}

" command {
    " 命令需要大写开头
    "command -nargs=+ Say :echo "<args>"
        "-nargs=0   zero
        "-nargs=1   one
        "-nargs=*   any
        "-nargs=?    one or zero
        "-nargs=+    one or more
        " <args>
        " <q-args>  包含特殊字符
        " <f-args>  适合函数调用

    "autocmd [group] {events} {file_pattern} [nested] {command}
    "autocmd BufNewFile     *.[ch]  0read ~/skeletons/skel.c     打开一个新文件
    "autocmd FileType       text    source ~/.vim/abbrevs.vim    设置filetype
    "autocmd BufReadPost    *.gsm   set filetype=asm             开始编辑一个文件

    command -nargs=* Breakline call BreakLine("<args>")
    function! BreakLine(args)
        if len(a:args) == 0
            execute "s/ /\r/g"
        else
            execute "s/".a:args."/\r/g"
        endif
    endfunc

    command -nargs=0 RevelInXcode call RevelInXcode()
    function! RevelInXcode()
        silent execute "!open -a /Applications/Xcode.app ".expand("%:p")
    endfunc

"}

" {
    " normal mode
    "g/xxx/d，删除包含xxx的行
    "v/xxx/d，删除不含xxx的行
    ":%s/xxx//gn，统计xxx个数，n表示只报告匹配的个数而不进行实际的替换。
"}

" zsh {
    if executable('zsh')
        set shell=/bin/zsh
    endif
"}

" Underline words matched by Matchmaker
function! ToggleMatchmaker()
    " Don’t show matches in non-code files
    if &ft =~ 'objc\|objcpp\|javascript\|swift'
        execute "Matchmaker"
    else
        " Specifically, I want it disabled on help, mkd
        execute "Matchmaker!"
    endif
endfun
autocmd BufEnter * call ToggleMatchmaker()
highlight Matchmaker guibg=NONE
highlight Matchmaker gui=underline
highlight Matchmaker ctermbg=NONE
highlight Matchmaker cterm=underline

" Insert Model use <C-r><C-r><C-\> to show all list in file
" after input use <C-\> show complete list
" <Tab> 和 <S-Tab> jump between placeholder

" :verbose set <option>? you can see where it's being set and what it's set to


"https://github.com/gorodinskiy/vim-coloresque/blob/master/after/syntax/css/vim-coloresque.vim
"the problem is at lines 125-126
" remove below line
":set isk+=-
":set isk+=#
":set isk+=.

" get rid of this 'Auto Commands' message
" http://stackoverflow.com/a/26382164
" There is an incomplete :autocmd definition

" Install jsctags first , depend on Ternjs
" npm install -g git+https://github.com/ramitos/jsctags.git
let g:tagbar_type_javascript = {
            \ 'ctagsbin' : '/usr/local/bin/jsctags'
            \}

" make split window equal defined in .vimrc defined again with noremap
noremap <Leader>= <C-w>=
noremap <silent> <Leader>/ :nohlsearch<CR>
noremap <Leader>bg :call ToggleBG()<CR>

" Swift {
    " completion popup menu KeyStroke
    "<Ctrl+N/Ctrl+P> scroll selection
    "<Ctrl+Y>  "yes, accept that word."
    "<Ctrl+E>  cancel the menu
    "See :help popupmenu-keys for more.

    " popup menu is visible use <C-Y>
    "Fixed: <Enter> insert newline
    autocmd FileType swift inoremap <expr> <CR> pumvisible() ? "\<C-Y>" : "\<CR>"
    autocmd FileType swift setlocal smartindent
    "autocmd FileType swift nnoremap <leader>r :make&<CR>

    command! Ff call FastSwiftCompile('')
    command! Fs call FastSwiftCompile('-s')
    function! FastSwiftCompile(flag)
        update
        let savemp = &makeprg

        if a:flag == '-s'
            let &makeprg = "sh"." /Users/dengjinlong/Documents/8-tvguo/FastCompileScript/simulator_fastCompile.sh"
        else
            let &makeprg = "sh"." /Users/dengjinlong/Documents/8-tvguo/FastCompileScript/ios_fastCompile.sh"
        endif

        silent make!
        let qflist = getqflist()
        let newqflist = []
        let isError = 0
        for d in getqflist()
            if d.lnum == 0 && isError == 1
                call add(newqflist, d)
            elseif d.lnum > 0 && d.text =~ 'error:*'
                call add(newqflist, d)
                let isError = 1
                "echo bufname(d.bufnr) ':' d.lnum '=' d.text
            else
                let isError = 0
            endif
        endfor

        if empty(newqflist)
            cclose
        else
            call setqflist(newqflist)
            copen
            "cfirst
        endif
        let &makeprg = savemp
    endfunction

    function FormatSwiftFile() range
        if a:firstline != a:lastline
            let l:start=a:firstline
            let l:end=a:lastline
            echomsg  "select line: ".l:start."-".l:end
        endif
        pyf $HOME/spf13-copy-vim/vim/swift-format.py
    endfunction

    function LLDBBreakLine()
      let @*="breakpoint set --file ".expand("%:t")." --line ".line(".")
    endfunction
    command! Llbr call LLDBBreakLine()
    function DjCopyLine()
      let @*=expand("%:t")." L".line(".")
    endfunction
    command! DjcopyLine call DjCopyLine()

    autocmd FileType swift vnoremap <silent> = :call FormatSwiftFile()<CR>
    autocmd FileType swift setlocal textwidth=240
" }




" java {
  autocmd FileType java set makeprg=javac\ *.java
  " Command Start with JC like :JCimportAdd
  autocmd FileType java setlocal omnifunc=javacomplete#Complete


  " single java file compile and run
  "nmap ,p :!javac %<CR>:!java -cp %:p:h %:t:r<CR>
  func! CompileRunGcc()
      exec "w"
      exec "!javac %"
      exec "!time java -cp %:p:h %:t:r"
  endfunction

  func! MultiJavaCompileRunGcc()
      exec "wall"
      exec "!javac *.java"
      exec "!time java -cp %:p:h Main"
  endfunction

  autocmd FileType java nnoremap \j :call MultiJavaCompileRunGcc()<CR>
"}

" ALE Setting {
  "let g:ale_dart_dartanalyzer_executable = ""
  "let g:ale_dart_language_server_executable = ""

  "gcc/clang 和 cppcheck，前者主要检查有无语法错误，后者主要会给出一些编码建议
  let g:ale_linters = {
  \   'javascript': ['eslint'],
  \   'vue': ['prettier'],
  \   'html': ['prettier'],
  \   'css': ['prettier'],
  \   'java': ['javac'],
  \   'md': ['proselint'],
  "\   'objc': ['clangd'],
  "\   'objcpp': ['clangd'],
  \   'swift': ['swiftformat'],
  \   'c': ['cppcheck', 'clangd'],
  \   'cpp': ['cppcheck', 'clangd'],
  \}

  let g:ale_fixers = {
  \   '*': ['remove_trailing_lines', 'trim_whitespace'],
  \  'javascript': ['prettier', 'eslint'],
  \  'vue': ['prettier'],
  \  'html': ['prettier'],
  \}

  " Only run linters named in ale_linters settings.
  let g:ale_linters_explicit = 1
  let g:ale_completion_enabled = 0

  let g:ale_sign_column_always = 1
  let g:ale_sign_error = '>>'
  let g:ale_sign_warning = '--'
  "highlight clear ALEErrorSign
  "highlight clear ALEWarningSign

  let g:ale_lint_on_text_changed = 'never'
  " if you don't want linters to run on opening a file
  let g:ale_lint_on_enter = 0
  let g:ale_lint_on_save=1

  " use the quickfix list instead of the loclist
  let g:ale_set_loclist = 0
  let g:ale_set_quickfix = 1
  let g:ale_open_list = 0


  noremap <space>ll :call QFixToggle()<CR>

function! QFixToggle()
  if exists("g:qfix_win")
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction

  "set omnifunc=ale#completion#OmniFunc
  " airline extension
  "let g:airline#extensions#ale#enabled = 1
  " jump between error
  "nmap <silent> <C-k> <Plug>(ale_previous_wrap)
  "nmap <silent> <C-j> <Plug>(ale_next_wrap)
"}

" markdown-preview.vim
let g:mkdp_path_to_chrome = "open -a Google\\ Chrome"

" vim-preview.vim  for md or html file
let g:PreviewBrowsers='open -a Google\ Chrome'

" complete with highlight syntax words
" http://www.vim.org/scripts/script.php?script_id=3172
" setlocal omnifunc=syntaxcomplete#Complete
"
" YCM complete Javascript setting below
" set completefunc=youcompleteme#Complete
" so the difference between completefunc and omnifunc
" completefunc: Insert mode completion with CTRL-X CTRL-U
" omnifunc: Insert mode omni completion with CTRL-X CTRL-O,  (:help i_CTRL-X_CTRL-O)
"   be used for filetype-specific completion

" only complete visiable buffers
let g:MultiWordComplete_complete = '.,w'

inoremap <C-x>e <C-R>=ListMonths()<CR>
func! ListMonths()
    call complete(col('.'), ['January', 'February', 'March',
                \ 'April', 'May', 'June', 'July', 'August', 'September',
                \ 'October', 'November', 'December'])
    return ''
endfunc


" quickhl
vmap H <Plug>(quickhl-manual-this)

" 不会跳到后面的匹配符号处
let g:AutoPairsMultilineClose=0

" https://github.com/fatih/vim-go-tutorial
" go {

  autocmd FileType go nmap <leader>r  <Plug>(go-run)

  let g:go_list_type = "quickfix"

  " :GoTest           run test
  " :GoTestFunc       test the function under cursor
  " :GoTestCompile    compile test files but not run test
  autocmd FileType go nmap <leader>t  <Plug>(go-test)

  " run :GoBuild or :GoTestCompile based on the go file
  function! s:build_go_files()
    let l:file = expand('%')
    if l:file =~# '^\f\+_test\.go$'
      call go#test#Test(0, 1)
    elseif l:file =~# '^\f\+\.go$'
      call go#cmd#Build(0)
    endif
  endfunction

  autocmd FileType go nmap <leader>b :<C-u>call <SID>build_go_files()<CR>

  " close auto formate
  " let g:go_fmt_autosave = 0

  " add missing import package when save
  let g:go_fmt_command = "goimports" " original is \"gofmt\"

  " too many highlight may be not good
  let g:go_highlight_types = 1
  let g:go_highlight_fields = 1
  let g:go_highlight_functions = 1
  let g:go_highlight_methods = 1
  let g:go_highlight_operators = 1
  let g:go_highlight_extra_types = 1
  let g:go_highlight_build_constraints = 1
  let g:go_highlight_generate_tags = 1

  autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4

  autocmd FileType go nmap <Leader>i <Plug>(go-info)
  let g:go_auto_type_info = 1

  let g:go_auto_sameids = 1

" }

"vimdiff current vs git head (fugitive extension)
"nnoremap <Leader>gd :Gdiff<cr>
"switch back to current file and closes fugitive buffer
"quit fugitive buffer or Geidt
"G log %
"G log -p % 可以显示每次提交的diff
":G log -10 -- %  Load the last 10 commits for the current file

nnoremap <Leader>qq :q!<CR>


" vim-airline
let g:airline#extensions#tabline#enabled = 1
let g:airline_symbols_ascii = 1

" Leaderf {
let g:Lf_ShortcutF = '<D-p>'
let g:Lf_ShortcutB = '<leader>fb'
let g:Lf_WildIgnore = {
            \ 'dir': ['.svn','.git','.hg', 'Target Support Files', 'Headers', '.cache'],
            \ 'file': ['*.sw?','~$*','*.bak','*.exe','*.o','*.so','*.py[co]']
            \}
let g:Lf_StlSeparator = { 'left': '', 'right': '' } " powerline font
let g:Lf_UseVersionControlTool=0  " Don't respect version control ignore files
nnoremap <silent> <D-r> :LeaderfMru<CR>
nnoremap <silent> <D-b> :LeaderfBuffer<CR>
nnoremap <silent> <leader>fs :LeaderfSelf<CR>
nnoremap <silent> <leader>ff :Leaderf file --cword<CR>
nnoremap <silent> <leader>ft :Leaderf tag --cword<CR>
nnoremap <silent> <leader>fl :Leaderf line<CR>

"let g:Lf_CtagsFuncOpts = {
"        \ 'c': '--c-kinds=fp',
"        \ 'c++': '--c++-kinds=fp',
"        \ 'swift': '',
"        \ }
"}

let g:dart_style_guide = 2
let dart_format_on_save = 0
autocmd FileType dart setlocal cinoptions=j1,J1,(2,m1
"source ~/.zshrc  " vim use system path and /etc/path.d only, need source custom profile file
"autocmd FileType dart setlocal completefunc=youcompleteme#Complete
"let g:lsc_server_commands = {'dart': 'dart_language_server'}
"let g:lsc_auto_map = {
    "\ 'GoToDefinition': '<C-]>',
    "\ 'FindReferences': 'gr',
    "\ 'NextReference': '<C-n>',
    "\ 'PreviousReference': '<C-p>',
    "\ 'FindImplementations': 'gI',
    "\ 'FindCodeActions': 'ga',
    "\ 'DocumentSymbol': 'go',
    "\ 'WorkspaceSymbol': 'gS',
    "\ 'ShowHover': 'K',
    "\ 'Completion': 'completefunc',
    "\}
"let g:lsc_trace_level = 'messages'

" iterm 刷新问题
"set ttyfast

" turn off the automatic deletion of trailing whitespace
let g:DeleteTrailingWhitespace = 0
let g:DeleteTrailingWhitespace_Action = 'delete'

let g:matchmaker_enable_startup = 1
" 没有匹配时，不显示下划线
let g:matchmaker_ignore_single_match = 1
" 优先级比其他插件低
let g:matchmaker_matchpriority = 0

" 使用 UltiSnipsEdit 命令时垂直分割屏幕
let g:UltiSnipsEditSplit="vertical"

autocmd FocusGained * call system('issw com.apple.keylayout.USExtended')

" for echodoc, not show mode hint in command line
set noshowmode

" gutentags {
    " gutentags 搜索工程目录的标志，当前文件路径向上递归直到碰到这些文件/目录名
    let g:gutentags_project_root = ['.root', '.svn', '.git', '.hg', '.project']
    let g:gutentags_exclude_project_root = ['/usr/local', '/Users/dengjinlong/spf13-copy-vim']

    " 所生成的数据文件的名称
    let g:gutentags_ctags_tagfile = '.tags'

    " 同时开启 ctags 和 gtags 支持：
    let g:gutentags_modules = []
    if executable('ctags')
        let g:gutentags_modules += ['ctags']
    endif
    if executable('gtags-cscope') && executable('gtags')
        let g:gutentags_modules += ['gtags_cscope']
    endif

    " 将自动生成的 ctags/gtags 文件全部放入 ~/.cache/tags 目录中，避免污染工程目录
    let g:gutentags_cache_dir = expand('~/.cache/tags')

    " 配置 ctags 的参数
    let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
    let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
    let g:gutentags_ctags_extra_args += ['--c-kinds=+px']

    " 如果使用 universal ctags 需要增加下面一行
    let g:gutentags_ctags_extra_args += ['--output-format=e-ctags']

    " exclude
    let g:gutentags_ctags_extra_args += ['--exclude=DerivedData']

    " 禁用 gutentags 自动加载 gtags 数据库的行为
    let g:gutentags_auto_add_gtags_cscope = 0
    let g:gutentags_exclude_project_root = ['/usr/local', '~/spf13-copy-vim', '~/flutter', '~/Documents/8-tvguo/FastCompileScript']
"}


set cmdheight=2
inoremap <silent><expr> <D-o> complete_parameter#pre_complete("()")
let g:complete_parameter_use_ultisnips_mapping = 1
" 被ultisnips修改
"smap <c-j> <Plug>(complete_parameter#goto_next_parameter)
"imap <c-j> <Plug>(complete_parameter#goto_next_parameter)
"smap <c-k> <Plug>(complete_parameter#goto_previous_parameter)
"imap <c-k> <Plug>(complete_parameter#goto_previous_parameter)

autocmd FileType html,vue,js set shiftwidth=2 tabstop=2 softtabstop=2 smartindent
au FileType vue set syntax=html

let g:lt_location_list_toggle_map = '<leader>cc'
let g:lt_quickfix_list_toggle_map = '<leader>qf'

set wildignore+=*.pyc,*.o,*.obj,*.svn,*.swp,*.class,*.hg,.DS_Store
let NERDTreeIgnore=['\.DS_Store$', '\.git$']

"org {
   let g:org_heading_shade_leading_stars = 0
   let g:org_agenda_files = ['~/org/*.org']
"}

" 显示缩进对齐线
let g:indentLine_enabled = 1

" startify {
    let g:startify_session_dir = '~/.vim/sessions'
    let g:startify_session_number = 5
    let g:startify_session_sort = 1
    let g:startify_files_number = 6

    let g:startify_bookmarks = [
                \ {'i': '~/Documents/jitu/1-JMS-Center-iOS'},
                \ {'r': '~/Documents/jitu/3-jtreact-codepush'},
                \ {'f': '~/Documents/jitu/3-flutter_jtcenter'},
                \ {'b': '~/Documents/blog/djlblogsource'},
                \ {'v': '~/Documents/jitu/jtbrain-vue'},
                \ {'j': '~/Documents/jitu/4-brain-center'}
                \]
    "if filereadable(expand("~/spf13-copy-vim/vimrc.startify.headers"))
        "source ~/spf13-copy-vim/vimrc.startify.headers
    "endif

    let g:startify_lists = [
          \ { 'type': 'files',     'header': ['   MRU']            },
          \ { 'type': 'sessions',  'header': ['   Sessions']       },
          \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
          \ { 'type': 'commands',  'header': ['   Commands']       },
          \ ]
" }

" ycm youcompleteme {
fun! GoYCM()
    "autocmd FileType * CocDisable

    nnoremap <buffer> <silent> <leader>gt :YcmCompleter GoTo<CR>
    nnoremap <buffer> <silent> <leader>gr :YcmCompleter GoToReferences<CR>

    " swift not auto complete for (, because not used too much
    let g:ycm_semantic_triggers =  {
        "\   'swift' : ['.', 're![_a-zA-Z]' ],
        \ 'c,cpp,python,java,go,erlang,perl': ['re!\w{2}'],
        \   'swift' : ['.'],
        \ }

  let g:ycm_filetype_blacklist = {
        \ 'tagbar': 1,
        \ 'notes': 1,
        \ 'markdown': 1,
        \ 'netrw': 1,
        \ 'unite': 1,
        \ 'text': 1,
        \ 'vimwiki': 1,
        \ 'pandoc': 1,
        \ 'infolog': 1,
        \ 'leaderf': 1,
        \ 'mail': 1,
        \ 'ycm_nofiletype': 1,
        \ 'startify': 1
        \}

    "http://www.skywind.me/blog/archives/2084
    let g:ycm_min_num_of_chars_for_completion = 3
    let g:ycm_add_preview_to_completeopt = 0
    let g:ycm_show_diagnostics_ui = 0
    let g:ycm_log_level = 'debug'
    let g:ycm_server_log_level = 'info'
    let g:ycm_min_num_identifier_candidate_chars = 2
    let g:ycm_collect_identifiers_from_comments_and_strings = 1
    let g:ycm_complete_in_strings=0

    " Because clang version not equal, clangd can't use
    " V[14:30:48.963] Ignored diagnostic. no handler registered for module format 'obj'
    " LLVM ERROR: unknown module format
    let g:ycm_use_clangd = 1
    let g:ycm_clangd_args = ['-log=verbose', '-pretty']
    " Let clangd fully control code completion
    "let g:ycm_clangd_uses_ycmd_caching = 0
    " Use installed clangd, not YCM-bundled clangd which doesn't get updates.
    "let g:ycm_clangd_binary_path = exepath("clangd")
    " generate compile_commads.json
    "xcodebuild -project PROJECT_NAME.xcodeproj | xcpretty -r json-compilation-database --output compile_commands.json
    "
    "YCM objc completion method length
    "YouCompleteMe/third_party/ycmd/cpp/ycm/CandidateRepository.cpp  L34 MAX_CANDIDATE_SIZE
    " https://haifengkao.medium.com/no-such-module-uikit-b51d2ce76e6  fix UIKit not found
    " it reads the arguments directly from .build/debug.yaml, which is generated by swift build

    " https://github.com/ycm-core/lsp-examples
    "
    "let SDKPATH = '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator14.3.sdk'
    "let g:ycm_lsp_dir = '~/Documents/5-Flutter/lsp-examples-master'
    "let g:ycm_language_server = [
      "\   {
      "\     'name': 'dart',
      "\     'cmdline': [ 'dart', expand( g:ycm_lsp_dir . '/dart/analysis_server.dart.snapshot' ), '--lsp' ],
      "\     'filetypes': [ 'dart' ],
      "\   },
      "\   {
      "\     'name': 'swift',
      "\     'cmdline': ['/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/sourcekit-lsp',
      "\         '-Xswiftc', '-sdk', '-Xswiftc', '/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator14.3.sdk',
      "\         '-Xswiftc', '-target', '-Xswiftc', 'x86_64-apple-ios14.3-simulator'
      "\     ],
      "\     'filetypes': [ 'swift' ],
      "\   },
      "\ ]
endfun
"}

"{ https://github.com/neoclide/coc.nvim
func! GoCoc()

    let g:ycm_auto_trigger = 0

    " Use <c-space> to trigger completion.
    if has('nvim')
        inoremap <silent><expr> <c-space> coc#refresh()
    else
        inoremap <silent><expr> <c-@> coc#refresh()
    endif

    " Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
    " position. Coc only does snippet and additional edit on confirm.
    " <cr> could be remapped by other vim plugin, try `:verbose imap <CR>`.
    if exists('*complete_info')
        inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
    else
        inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
    endif

    " Use `[g` and `]g` to navigate diagnostics
    " Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
    nmap <silent> [g <Plug>(coc-diagnostic-prev)
    nmap <silent> ]g <Plug>(coc-diagnostic-next)

    " GoTo code navigation.
    nmap <silent> gd <Plug>(coc-definition)
    nmap <silent> gy <Plug>(coc-type-definition)
    nmap <silent> gi <Plug>(coc-implementation)
    nmap <silent> gr <Plug>(coc-references)

    " Use K to show documentation in preview window.
    nnoremap <silent> K :call <SID>show_documentation()<CR>

    function! s:show_documentation()
        if (index(['vim','help'], &filetype) >= 0)
            execute 'h '.expand('<cword>')
        else
            call CocAction('doHover')
        endif
    endfunction

    " Highlight the symbol and its references when holding the cursor.
    autocmd CursorHold * silent call CocActionAsync('highlight')

    " Symbol renaming.
    nmap <leader>rn <Plug>(coc-rename)

    " Formatting selected code.
    xmap <leader>f  <Plug>(coc-format-selected)
    nmap <leader>f  <Plug>(coc-format-selected)

    augroup mygroup
        autocmd!
        " Setup formatexpr specified filetype(s).
        autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
        " Update signature help on jump placeholder.
        autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
    augroup end

    " Applying codeAction to the selected region.
    " Example: `<leader>aap` for current paragraph
    xmap <leader>a  <Plug>(coc-codeaction-selected)
    nmap <leader>a  <Plug>(coc-codeaction-selected)

    " Remap keys for applying codeAction to the current buffer.
    nmap <leader>ac  <Plug>(coc-codeaction)
    " Apply AutoFix to problem on the current line.
    nmap <leader>qf  <Plug>(coc-fix-current)

    " Map function and class text objects
    " NOTE: Requires 'textDocument.documentSymbol' support from the language server.
    xmap if <Plug>(coc-funcobj-i)
    omap if <Plug>(coc-funcobj-i)
    xmap af <Plug>(coc-funcobj-a)
    omap af <Plug>(coc-funcobj-a)
    xmap ic <Plug>(coc-classobj-i)
    omap ic <Plug>(coc-classobj-i)
    xmap ac <Plug>(coc-classobj-a)
    omap ac <Plug>(coc-classobj-a)

    " Use CTRL-S for selections ranges.
    " Requires 'textDocument/selectionRange' support of LS, ex: coc-tsserver
    nmap <silent> <C-s> <Plug>(coc-range-select)
    xmap <silent> <C-s> <Plug>(coc-range-select)

    " Add `:Format` command to format current buffer.
    command! -nargs=0 Format :call CocAction('format')

    " Add `:Fold` command to fold current buffer.
    command! -nargs=? Fold :call     CocAction('fold', <f-args>)

    " Add `:OR` command for organize imports of the current buffer.
    command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

    " Add (Neo)Vim's native statusline support.
    " NOTE: Please see `:h coc-status` for integrations with external plugins that
    " provide custom statusline: lightline.vim, vim-airline.
    set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

    " Mappings for CoCList
    " Show all diagnostics.
    nnoremap <silent><nowait> <space>a  :<C-u>CocList diagnostics<cr>
    " Manage extensions.
    nnoremap <silent><nowait> <space>e  :<C-u>CocList extensions<cr>
    " Show commands.
    nnoremap <silent><nowait> <space>c  :<C-u>CocList commands<cr>
    " Find symbol of current document.
    nnoremap <silent><nowait> <space>o  :<C-u>CocList outline<cr>
    " Search workspace symbols.
    nnoremap <silent><nowait> <space>s  :<C-u>CocList -I symbols<cr>
    " Do default action for next item.
    nnoremap <silent><nowait> <space>j  :<C-u>CocNext<CR>
    " Do default action for previous item.
    nnoremap <silent><nowait> <space>k  :<C-u>CocPrev<CR>
    " Resume latest coc list.
    nnoremap <silent><nowait> <space>p  :<C-u>CocListResume<CR>
endfun
"}

nnoremap <silent> <leader>y  :<C-u>CocList -A --normal yank<cr>
" :CocCommand yank.clean
" append result on current expression
nmap <Leader>ca <Plug>(coc-calc-result-append)
" replace result on current expression
nmap <Leader>cr <Plug>(coc-calc-result-replace)

nmap <Leader>tl <Plug>(coc-translator-p)
vmap <Leader>tl <Plug>(coc-translator-pv)

autocmd FileType * call GoYCM()
"autocmd FileType * call GoCoc()
"autocmd FileType cpp,cxx,h,hpp,c call GoCoc()

let g:alternateExtensions_m = "h"
let g:alternateExtensions_h = "m"
let g:XkbSwitchEnabled = 1
let g:XkbSwitchNLayout = 'us'
autocmd BufEnter * let b:XkbSwitchILayout = 'us'

nnoremap <leader>gs :G<CR>
nnoremap <leader>gc :Gcommit -v -q<CR>
nnoremap <leader>ga :Gcommit --amend<CR>
nnoremap <leader>gt :Gcommit -v -q %<CR>
nnoremap <leader>gd :Gvdiffsplit<CR>
nnoremap <leader>ge :Gedit<CR>
nnoremap <leader>gr :Gread<CR>
nnoremap <leader>gw :Gwrite<CR><CR>
nnoremap <leader>gl :0Gclog! -5<CR>
nnoremap <leader>gb :Git branch<CR>
nnoremap <leader>gm :Gmove<Space>
nnoremap <leader>go :Git checkout<Space>

"command -nargs=0 Tybuild :call job_start('/Users/dengjinlong/Documents/tuya/compile.sh')

autocmd BufNewFile,BufRead *.iconfont set guifont=iconfont:h30

" Asks for confirmation before deleting all marks/markers
let g:SignaturePurgeConfirmation = 1

"Copy file path
nnoremap <silent> <space>cpp :let @*=expand("%:p")<cr>:echo '-= File path copied=-'<cr>
"Copy file name
nnoremap <silent> <space>cpf :let @*=expand("%:t")<cr>:echo '-= File name copied=-'<cr>
"Copy bookmark position reference
nnoremap <silent> <space>cpb :let @*=expand("%:p").':'.line(".").':'.col(".")<cr>:echo '-= Cursor bookmark copied=-'<cr>

"Open scratch split buffers
nnoremap <silent> <space>ttss<space> :new<cr>:setl bt=nofile bh=wipe nobl noswf<cr>
nnoremap <silent> <space>ttsv<space> :vnew<cr>:setl bt=nofile bh=wipe nobl noswf<cr>
"}}}
"########## Run Command ##########{{{
nmap <space>sh<space> yy<space>ttss<space>P:.!zsh<cr>
xmap <space>sh<space> y<space>ttss<space>P:%!zsh<cr>
"}}}
