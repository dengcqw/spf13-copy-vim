" local user configuration

" misc {
    " Set to auto read when a file is changed from the outside
    set autoread

    " Height of the command bar
    set cmdheight=2

    " Don't redraw while executing macros (good performance config)
    " ?
    set lazyredraw

    " No annoying sound on errors
    set noerrorbells
    set novisualbell

    " Add a bit extra margin to the left
    set foldcolumn=1

    " Use Unix as the standard file type
    set ffs=unix,dos,mac

    " Turn backup off, since most stuff is in SVN, git et.c anyway...
    set nobackup
    set nowb
    set noswapfile

    " Remember info about open buffers on close
    " My session manager has saved session viminfo, but other buffer needs viminfo too.
    set viminfo^=%
    " Remap VIM 0 to first non-blank character
    map 0 ^
    "{
        " Move a line of text using ALT+[jk] or Comamnd+[jk] on mac in visual mode
        nmap <M-j> mz:m+<cr>`z
        nmap <M-k> mz:m-2<cr>`z
        vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
        vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z

        if has("mac") || has("macunix")
            nmap <D-j> <M-j>
            nmap <D-k> <M-k>
            vmap <D-j> <M-j>
            vmap <D-k> <M-k>
        endif
    "}

    " select block
    noremap vab Vf{%

    " Remove the Windows ^M - when the encodings gets messed up
    "noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

    " Toggle paste mode on and off
    noremap <Leader>pp :setlocal paste!<cr>

    set nospell

    " % match pairs
    set matchpairs+=<:>
"}

" relative number {
    set number
    " switch relative number and normal number
    function! NumberToggle()
      if(&relativenumber == 1)
        set number
      else
        set relativenumber
      endif
    endfunc
"}


" tab {
    " Useful mappings for managing tabs
    nnoremap <Leader>tn :tabnew<cr>
    " nnoremap <Leader>to :tabonly<cr>
    nnoremap <Leader>tc :tabclose<cr>
    nnoremap <Leader>tm :tabmove
    " shift tab pages; i is ahead of o  likt <C-I><C-O>
    nnoremap <Leader>ti :tabp<CR>
    nnoremap <Leader>to :tabn<CR>
    " Opens a new tab with the current buffer's path
    " Super useful when editing files in the same directory
    nnoremap <Leader>te :tabedit <c-r>=expand("%:p:h")<cr>
" }


"vimgrep searching and cope displaying {
    " Visual mode pressing * or # searches for the current selection
    " Super useful! From an idea by Michael Naumann
    vnoremap <silent> * :call VisualSelection('f', '')<CR>
    vnoremap <silent> # :call VisualSelection('b', '')<CR>

    " When you press gv you vimgrep after the selected text
    vnoremap <silent> gv :call VisualSelection('gv', '')<CR>
    vnoremap <silent> K :call VisualSelection('K', '')<CR>

    " When you press <Leader>r you can search and replace the selected text
    "vnoremap <silent> <Leader>r :call VisualSelection('replace', '')<CR>

    " Do :help cope if you are unsure what cope is. It's super useful!
    "
    " When you search with vimgrep, display your results in cope by doing:
    "   <Leader>cc
    "
    " To go to the next search result do:
    "   <Leader>n
    "
    " To go to the previous search results do:
    "   <Leader>p
    "
    " map <Leader>cc :botright cope<cr>
    " map <Leader>co ggVGy:tabnew<cr>:set syntax=qf<cr>pgg
    " map <Leader>n :cn<cr>
    " map <Leader>p :cp<cr>

    function! CmdLine(str)
        exe "menu Foo.Bar :" . a:str
        emenu Foo.Bar
        unmenu Foo
    endfunction

    function! VisualSelection(direction, extra_filter) range
        let l:saved_reg = @"
        execute "normal! vgvy"

        let l:pattern = escape(@", '\\/.*$^~[]')
        let l:pattern = substitute(l:pattern, "\n$", "", "")

        if a:direction == 'b'
            execute "normal ?" . l:pattern . "^M"
        elseif a:direction == 'gv'
            call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.' . a:extra_filter)
        elseif a:direction == 'replace'
            call CmdLine("%s" . '/'. l:pattern . '/')
        elseif a:direction == 'f'
            execute "normal /" . l:pattern . "^M"
        elseif a:direction == 'K'
            execute 'Ack! ' . '"' . l:pattern . '"'
        endif

        let @/ = l:pattern
        let @" = l:saved_reg
    endfunction
" }

" buffer {
    " Close the current buffer
    map <Leader>bd :Bclose<cr>
    " Close all the buffers
    map <Leader>ba :1,100 bd!<cr>

    " Don't close window, when deleting a buffer
    command! Bclose call <SID>BufcloseCloseIt()
    function! <SID>BufcloseCloseIt()
       let l:currentBufNum = bufnr("%")
       let l:alternateBufNum = bufnr("#")

       if buflisted(l:alternateBufNum)
         buffer #
       else
         bnext
     endif

       if bufnr("%") == l:currentBufNum
         new
       endif

       if buflisted(l:currentBufNum)
         execute("bdelete! ".l:currentBufNum)
       endif
    endfunction
" }

" deng custom {
    set textwidth=120  " max length of a line

    "=====Folds=====
    set foldmethod=indent   " fold based on indent
    set foldnestmax=9       " deepest fold is 3 levels
    set nofoldenable        " don't fold by default
    nnoremap <Space> za     " use space to do fold

    " add filename after command
    noremap <Leader>vd :vertical diffsplit
    " Only needed for a short time so...
    noremap <Leader>fd :setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1<CR>

    " set ; to : in normal mode, more fast to cmd mode.
    nnoremap ; :
    nnoremap : ;

    " not replace paste content
    xnoremap p pgvy

    noremap <Leader>m :marks<CR>

    set encoding=utf-8
    set fenc=utf-8
    set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1

    noremap <Leader>w :w<CR>
    " replace a word
    nmap vp viwp

    " when switch vertical windows, make the other window visiable
    set winheight=5
    set winminheight=5

    " display bottom scroller
    set guioptions+=b

    set lines=80

    set complete=.,b,u,U,t,i,k

    inoremap <D-p> <c-x><c-p>

    "Line modifications
    "inoremap CC <Esc>C  " or use <C-k>
    "inoremap SS <Esc>S
    "inoremap DD <Esc>dd " or <Cmd-backspace>
    "Quick movements
    "inoremap II <Esc>I
    "inoremap AA <Esc>A
    "inoremap OO <Esc>O
" }

" custom Plugins {

    """"""""""""""""""""""""""""""""""""""""
    " powerline plugin
    "let g:Powerline_symbols = 'fancy'

    """""""""" NERDtree settings"""""""""""""""
    let g:NERDTreeWinPos='left'

    """"""""""EasyMotion settings""""""""""
    ""let g:EasyMotion_leader_key = '\'
        " ff[ch]
        " fs[ch]    Search
        " fw    word
        " fj    line downward
        " fk    line upward
        " fn/fN    like original n/N
" }
"

" emmet
let g:user_emmet_leader_key = '<C-S>'
let g:user_emmet_install_global = 0
autocmd FileType html,css,ejs EmmetInstall


" js beautify
augroup filetype_jsbuty
    autocmd!
    autocmd FileType javascript vnoremap <buffer> <C-S> :call RangeJsBeautify()<cr>
    autocmd FileType javascript vnoremap <buffer> <C-H> :call RangeHtmlBeautify()<cr>
    autocmd FileType json vnoremap <buffer> <C-S> :call RangeJsonBeautify()<cr>
    autocmd FileType jsx vnoremap <buffer>  <C-S> :call RangeJsxBeautify()<cr>
    autocmd FileType html vnoremap <buffer> <C-S> :call RangeHtmlBeautify()<cr>
    autocmd FileType css vnoremap <buffer>  <C-S> :call RangeCSSBeautify()<cr>
augroup END


" ----------------------------------------------------------------------------
" tern_for_vim
" ----------------------------------------------------------------------------
let g:tern_show_argument_hints='on_hold'
let g:tern_show_signature_in_pum=1
let g:tern_map_keys=1
let g:tern_map_prefix='/'
let g:tern_request_timeout=3
augroup filetype_tern
    autocmd!
    autocmd FileType javascript nnoremap <Leader>d :TernDef<CR>
    autocmd FileType javascript setlocal omnifunc=tern#Complete
augroup END
" vim-javascript.vim
let g:javascript_enable_domhtmlcss = 1
"javascript-libraries-syntax.vim
"autocmd BufReadPre *.js let b:javascript_lib_use_jquery = 1
let g:used_javascript_libs = 'underscore,react'
" vim-jsx.vim
let g:jsx_ext_required = 0

function! ChangeJavascriptTab()
    set tabstop=2
    set softtabstop=2
    set shiftwidth=2
    set expandtab
endfunction

augroup filetype_jsformat
    autocmd!
    autocmd FileType javascript :call ChangeJavascriptTab()
augroup END

"surrounding command list {
    "Normal mode
    "-----------
    "ds  - delete a surrounding
    "cs  - change a surrounding
    "ys  - add a surrounding
    "yS  - add a surrounding and place the surrounded text on a new line + indent it
    "yss - add a surrounding to the whole line
    "ySs - add a surrounding to the whole line, place it on a new line + indent it
    "ySS - same as ySs

    "Visual mode
    "-----------
    "S   - in visual mode, add a surrounding but place text on new line + indent it

    "Insert mode
    "-----------
    "<CTRL-s> - in insert mode, add a surrounding
    "<CTRL-s><CTRL-s> - in insert mode, add a new line + surrounding + indent
    "<CTRL-g>s - same as <CTRL-s>
    "<CTRL-g>S - same as <CTRL-s><CTRL-s>
    inoremap ]] <ESC>:execute "normal yss]"<CR>A
"}
"

" fix NERDTreeToggle error strangely. {
    "noremap <C-e> :call g:WorkaroundNERDTreeToggle()<CR>

    "function! g:WorkaroundNERDTreeToggle()
      "try | NERDTreeTabsToggle | catch | silent! NERDTree | endtry
    "endfunction

    noremap <Leader>pr :NERDTreeFind<CR>
"}


" buffer switch {
    function! BufSel(pattern)
      let bufcount = bufnr("$")
      let currbufnr = 1
      let nummatches = 0
      let firstmatchingbufnr = 0
      while currbufnr <= bufcount
        if(bufexists(currbufnr))
          let currbufname = bufname(currbufnr)
          if(match(currbufname, a:pattern) > -1)
            echo currbufnr . ": ". bufname(currbufnr)
            let nummatches += 1
            let firstmatchingbufnr = currbufnr
          endif
        endif
        let currbufnr = currbufnr + 1
      endwhile
      if(nummatches == 1)
        execute ":buffer ". firstmatchingbufnr
      elseif(nummatches > 1)
        let desiredbufnr = input("Enter buffer number: ")
        if(strlen(desiredbufnr) != 0)
          execute ":buffer ". desiredbufnr
        endif
      else
        echo "No matching buffers"
      endif
    endfunction

    "Bind the BufSel() function to a user-command
    command! -nargs=1 Bs :call BufSel("<args>")
    noremap <Leader>bs :Bs<Space>
"}

set foldlevelstart=1

" ctrlp {
    "https://kien.github.io/ctrlp.vim/
    "使用:CtrlP或:CtrlP [starting-directory]调用CtrlP进入查找文件模式
    "使用:CtrlPBuffer或:CtrlPMRU进入查找buffer或者查找MRU文件模式
    "使用:CtrlPMixed同时搜索普通文件、Buffers或者MRU文件
    "可以使用:help ctrlp-commands和:help ctrlp-extensions查看其他命令帮助

    "一旦CtrlP被打开了，就可以使用以下的命令
        "<F5> 清除当前目录下的缓存，获取新的结构
        "<c-f>和<c-b> 在各个模式下转换
        "<c-d> 使用文件名搜索代替全路径搜索
        "<c-r> 使用正则模式
        "<c-j>和<c-k> 上下选择文件
        "<c-t> <c-v>和<c-x> 在新的tab或者新的分割窗口打开选择的文件
        "<c-n>和<c-p> 找到之前或者之后查找的字符串
        "<c-y> 创建一个新的文件
        "<c-z> 标记或者取消标记多个文件然后使用<c-o>打开它们
        "<c-o> 选择打开方式
        "
    " use ,fu search fun tag -> CtrlPFunky
    let g:ctrlp_max_depth = 40
    let g:ctrlp_max_files = 0
    let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:20,results:100'
    " search by file name
    let g:ctrlp_by_filename = 1
    " home path display ~
    let g:ctrlp_tilde_homedir = 1
    " only show current working dir recent files.
    " open new buffer to open other recent files
    let g:ctrlp_mruf_relative = 1
    " NOTE:
        " if install ag with brew, below setting will be invalid
        " let g:ctrlp_custom_ignore
        " edit ~/.agignore to add folders to be ignore.
        " Ag will ignore anything that you have in your .gitignore.
        " You can also create an .agignore for anything that doesn’t belong in your .gitignore.
        " http://erickel.ly/ignoring-filesdirectories-with-ctrlp

    " current dir
    let g:ctrlp_map = '<D-p>'
    let g:ctrlp_cmd = 'CtrlP'
    " recent files
    nnoremap <silent> <D-r> :CtrlPMRU<CR>
    " buffers
    nnoremap <silent> <D-b> :CtrlPBuffer<CR>

    if has('python') || has('python3')
        let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
    endif

    " Use <c-n/p> to select item and <c-j/k> browse history
    let g:ctrlp_prompt_mappings = {
    \ 'PrtSelectMove("j")':   ['<c-n>', '<down>'],
    \ 'PrtSelectMove("k")':   ['<c-p>', '<up>'],
    \ 'PrtHistory(-1)':       ['<c-j>'],
    \ 'PrtHistory(1)':        ['<c-k>'],
    \ }

    " use word under cursor as CtrlP input
    nnoremap <Leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<CR>
    " https://github.com/kien/ctrlp.vim/issues/218
    nnoremap <silent> <Leader>fw :let g:ctrlp_default_input = expand('<cword>')<cr>:CtrlP<cr>

    " 可以参考
    " https://github.com/fisadev/fisa-vim-config
    "{  这种方法有点玄幻
        "function! CtrlPWithSearchText(search_text, ctrlp_command_end)
            "execute ':CtrlP' . a:ctrlp_command_end
            "call feedkeys(a:search_text)
        "endfunction
        "nnoremap ,we :call CtrlPWithSearchText(expand('<cword>'), '')<CR>
    "}
    " }

"{
    "Cocoa.vim
    ":help cocoa
    "cocoa.vim uses snipMate to code completion
    "<c-x><c-o>
    "<tab>
    "useful plugin: objc_matchbracket.vim
    ":ListMethods
    ":BuildMethods .h -> .m
    "look document
    ":CocoaDoc
    "K
    "Xcode-like mappings
    "<Leader>A Alternate between header (.h) and implementation (.m) file
    "K Look up documentation for word under cursor
    "<d-m-up> equal <Leader>A
    "<d-r> Build & Run (Go)
    "<d-cr> CMD-R
    "<d-b> Build
    "<shift-k> Clean
    "<d-0> Go to Project
    "<d-2> :ListMethods
    "<F5> (in insert mode) Show omnicompletion menu
    "<d-/> Comment out line
    "<d-[> Decrease indent
    "<d-]> Increase indent
    "a.vim
    ":A switches to the header file corresponding to the current file being edited (or vise versa)
    ":AS splits and switches
    ":AV vertical splits and switches
    ":AT new tab and switches
    ":AN cycles through matches
    ":IH switches to file under cursor
    ":IHS splits and switches
    ":IHV vertical splits and switches
    ":IHT new tab and switches
    ":IHN cycles through matches
    "<Leader>ih switches to file under cursor
    "<Leader>is switches to the alternate file of file under cursor (e.g. on switches to foo.cpp)
    "<Leader>ihn cycles through matches
"}

" Easy motion {
    let g:EasyMotion_smartcase = 1
    let g:EasyMotion_off_screen_search = 0
    let g:EasyMotion_disable_two_key_combo = 1
    " 行级跳转(jk)
    map <Leader>j <Plug>(easymotion-j)
    map <Leader>k <Plug>(easymotion-k)
    " 行内跳转(hl)
    map <Leader>h <Plug>(easymotion-linebackward)
    map <Leader>l <Plug>(easymotion-lineforward)
    " 重复上一次动作(.)
    map <Leader>. <Plug>(easymotion-repeat)
"}

" K -- the uppercase k search current folder
" {
    if executable('ag')
      " Use ag over grep
      set grepprg=ag\ --nogroup\ --nocolor
    endif

    "autocmd FileType shell setlocal keyworkprg=man\ -s
    set keywordprg=grep\ --color=auto\ -r\ -n\ ./*\ -e

    " set grep search root dir, save with session
    " file path can't contain white space
    " iOS SDK root: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.2.sdk
    " Tips: Don't change path to the file, keep the project path, use ,pr to locate file in NERD tree
    function! GrepCustomDir(word)
        " use ag search
        "execute 'grep! ' . a:word . ' ' . './'
        execute 'Ack! ' . a:word
        cw
    endfunction

    nnoremap K :call GrepCustomDir("<C-R><C-W>")<CR>
"}

" ycm youcompleteme {
    nnoremap <Leader>d :YcmCompleter GoToDefinition <cr>
    nnoremap <Leader>s :YcmCompleter GoToDeclaration <cr>

    let g:ycm_filetype_blacklist = {
      \ 'tagbar' : 1,
      \ 'qf' : 1,
      \ 'notes' : 1,
      \ 'markdown' : 1,
      \ 'unite' : 1,
      \ 'text' : 1,
      \ 'vimwiki' : 1,
      \ 'gitcommit' : 1,
      \}
    let g:ycm_semantic_triggers = {
                \ 'objc' : ['re!\@"\.*"\s',
                \ 're!\@\w+\.*\w*\s',
                \ 're!\@\(\w+\.*\w*\)\s',
                \ 're!\@\(\s*',
                \ 're!\@\[.*\]\s',
                \ 're!\@\[\s*',
                \ 're!\@\{.*\}\s',
                \ 're!\@\{\s*',
                \ "re!\@\’.*\’\s",
                \ '#ifdef ',
                \ 're!:\s*',
                \ 're!=\s*',
                \ 're!,\s*', ],
                \ }
"}

" copy file path {
    " copy current file name (relative/absolute) to system clipboard
    if has("mac") || has("gui_macvim") || has("gui_mac")
      " relative path  (src/foo.txt)
      nnoremap <Leader>cf :let @*=expand("%")<CR>

      " absolute path  (/something/src/foo.txt)
      nnoremap <Leader>cF :let @*=expand("%:p")<CR>

      " filename       (foo.txt)
      nnoremap <Leader>ct :let @*=expand("%:t")<CR>

      " directory name (/something/src)
      nnoremap <Leader>ch :let @*=expand("%:p:h")<CR>
    endif
"}

" http://www.vimer.cn/2009/10/%E5%9C%A8vim%E4%B8%AD%E4%BD%BF%E7%94%A8ctags.html
" brew install ctags --HEAD
" find . -name "*.h" -o -name "*.c" -o -name "*.cpp" -o -name "*.m" -o -name "*.mm" -o -name "*.js"> src.files
" ctags --exclude='.git' -R --c++-kinds=+px --fields=+iaS --extra=+q --langmap=ObjectiveC:.m.h -L src.files
" set tags+=tags的文件路径
" tagbar 替代了 taglist
" 解析非常严格需要格式代 brew install clang-format
" objc tags {
    "http://bastibe.de/2011-12-04-how-to-make-tagbar-work-with-objective-c.html
    " add a definition for Objective-C to tagbar
 let g:tagbar_type_objc = {
    \ 'ctagstype' : 'ObjectiveC',
    \ 'kinds'     : [
        \ 'i:interface',
        \ 'I:implementation',
        \ 'p:Protocol',
        \ 'm:Object_method',
        \ 'c:Class_method',
        \ 'v:Global_variable',
        \ 'F:Object field',
        \ 'f:function',
        \ 'p:property',
        \ 't:type_alias',
        \ 's:type_structure',
        \ 'e:enumeration',
        \ 'M:preprocessor_macro',
    \ ],
    \ 'sro'        : ' ',
    \ 'kind2scope' : {
        \ 'i' : 'interface',
        \ 'I' : 'implementation',
        \ 'p' : 'Protocol',
        \ 's' : 'type_structure',
        \ 'e' : 'enumeration'
    \ },
    \ 'scope2kind' : {
        \ 'interface'      : 'i',
        \ 'implementation' : 'I',
        \ 'Protocol'       : 'p',
        \ 'type_structure' : 's',
        \ 'enumeration'    : 'e'
    \ }
\ }

    " ctags --list-kinds=all
    " ctags --list-kinds=ObjectiveC
    "ObjectiveC
        "i  class interface
        "I  class implementation
        "p  Protocol
        "m  Object's method
        "c  Class' method
        "v  Global variable
        "F  Object field
        "f  A function
        "p  A property
        "t  A type alias
        "s  A type structure
        "e  An enumeration
        "M  A preprocessor macro
    "JavaScript
        "f  functions
        "c  classes
        "m  methods
        "p  properties
        "v  global variables
"}

" Useful Substitute {
    " Del line tail blank space 行尾空格
    ":%s/\s\+$//

    "Doe, John > John Doe
    ":%s/\([^,]*\), \(.*\)/\2 \1/
"}:%s/\s\+$//


" gf search path and sub path {
    if isdirectory(expand(g:gitroot))
        execute 'set path=./**,' . g:gitroot . '/**'
    endif
"}

" expand tab {
    "function! ChangeTabToSpace()
        "set expandtab
        "%retab!
    "endfunction

    "function! ChangeSpace2Tab()
        "set noexpandtab
        "%retab!
    "endfunction

    "command -nargs=0 ChangeSpace2Tab :call ChangeSpace2Tab()
    "command -nargs=0 ChangeTab2Space :call ChangeTab2Space()
"}

" command {
    " 命令需要大写开头
    "command -nargs=+ Say :echo "<args>"
        "-nargs=0   zero
        "-nargs=1   one
        "-nargs=*   any
        "-nargs=?    one or zero
        "-nargs=+    one or more
        " <args>
        " <q-args>  包含特殊字符
        " <f-args>  适合函数调用

    "autocmd [group] {events} {file_pattern} [nested] {command}
    "autocmd BufNewFile     *.[ch]  0read ~/skeletons/skel.c     打开一个新文件
    "autocmd FileType       text    source ~/.vim/abbrevs.vim    设置filetype
    "autocmd BufReadPost    *.gsm   set filetype=asm             开始编辑一个文件
"}

" {
    " normal mode
    "g/xxx/d，删除包含xxx的行
    "v/xxx/d，删除不含xxx的行
    ":%s/xxx//gn，统计xxx个数，n表示只报告匹配的个数而不进行实际的替换。
"}

" zsh {
    if executable('zsh')
        set shell=/bin/zsh
    endif
"}

" Underline words matched by Matchmaker
function! ToggleMatchmaker()
    " Don’t show matches in non-code files
    if &ft =~ 'objc\|objcpp\|javascript\|swift'
        execute "Matchmaker"
    else
        " Specifically, I want it disabled on help, mkd
        execute "Matchmaker!"
    endif
endfun
autocmd BufEnter * call ToggleMatchmaker()
highlight Matchmaker guibg=NONE
highlight Matchmaker gui=underline
highlight Matchmaker ctermbg=NONE
highlight Matchmaker cterm=underline

" Insert Model use <C-r><C-r><C-\> to show all list in file
" after input use <C-\> show complete list
" <Tab> 和 <S-Tab> jump between placeholder

let g:PreviewBrowsers='open -a Google\ Chrome'

" :verbose set <option>? you can see where it's being set and what it's set to

""""""""""""""""""""""""""""""""""""""""""""""
"set encoding=utf-8
"set fileencoding=utf-8
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8,gb18030,cp936,big5,euc-jp,euc-kr,latin1
""""""""""""""""""""""""""""""""""""""""""""""

"https://github.com/gorodinskiy/vim-coloresque/blob/master/after/syntax/css/vim-coloresque.vim
"the problem is at lines 125-126
" remove below line
":set isk+=-
":set isk+=#
":set isk+=.

"set nocursorline
set nocursorcolumn
set synmaxcol=200

" get rid of this 'Auto Commands' message
" http://stackoverflow.com/a/26382164
" There is an incomplete :autocmd definition

let g:easytags_cmd = '/usr/local/Cellar/ctags/5.8_1/bin'
let g:easytags_always_enabled = 0
let g:easytags_async = 1
let g:easytags_on_cursorhold = 0
"let g:easytags_updatetime_min = 6000

" Install jsctags first , depend on Ternjs
" npm install -g git+https://github.com/ramitos/jsctags.git
let g:tagbar_type_javascript = {
            \ 'ctagsbin' : '/usr/local/bin/jsctags'
            \}

" make split window equal defined in .vimrc defined again with noremap
noremap <Leader>= <C-w>=
noremap <silent> <Leader>/ :nohlsearch<CR>
noremap <Leader>bg :call ToggleBG()<CR>

